\chapter{The scheme}
% A short description of what we will present --- what we have done.

\section{Sequential (seq)}
The framework contained a sequential prefetcher as a starting point.
Modifications related to the prefetch distance and degree where tried.
% An example?
Also the criteria for starting prefetching sequential where tried modified.
% Or was it? I seem to think so at least, find the change and document it.

% Also add the result and try to explain them.

Created a trivial test program (accumulate.c) that accessed a large sequential
chunk of memory in a tight loop body to assess the optimal prefetch distance
for this type of code structure. This estimates the best possible performance
gain for sequential prefetching for shortest possible loop body and the
measured optimum acts therefore as an upper bound for how many elements should
be present in cache to overlap the time it takes to prefetch enough new
elements to refill the consumption of elements from cache.

\section{Reference Prediction Table (RPT)}

\section{Delta Correlating Prediction Table}
The algorithm for DCPT (Delta Correlating Prediction Table) is based on the pseudo code from \cite{dcptpaper}.
The implementation is very near RPT, but the difference is that it looks for a pattern instead of one stride.
When the it gets a request, it saves the (PC) program counter, and the stride in a table connected to each PC. When it has more than two elements in the list with strides, it starts looking for patterns.
If it finds a pattern in the list, it saves all the adresses that possibly should be prefetched in another list with candidates for prefetch.
Then it runs through the list and checks if the adresses is not in the cache, in the mshr or that the adress is out of memory. If all the requirements are met, it issues a prefetch for it.

The first implementation done, did something wrong according to \cite{dcptpaper}, it did not use the deltas like they should. It prefetched all adresses that came after the matching sequence, but all the adresses used the same adress as base, so if there was a array of deltas like 1,2,3,4,1,2,5,1,2 and the last memory adress was 10, it would prefetch: 10+3, 10+4, 10+1, 10+2, 10+5.

The second implemenation should do it right according to \cite{dcptpaper}, it would with the same sequence as the last example prefetch: 10+5, 15+1, 16+2, 18+1, 19+2, 21+3, 24+4.

Attempts to tweak this implementation:
- Make a copy of the queue to keep track of which adresses that still aren't fetched, to avoid "double fetching".
- Make a lru which prevents the prefetcher from throwing out recently used history from the list.
- Adjustments to the size of the list, and size of the delta list


